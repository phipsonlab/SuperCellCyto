% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runSuperCellCyto.R
\name{runSuperCellCyto}
\alias{runSuperCellCyto}
\title{Run SuperCell for cytometry data}
\usage{
runSuperCellCyto(
  dt,
  markers,
  sample_colname,
  cell_id_colname,
  gam = 20,
  k_knn = 5,
  BPPARAM = SerialParam(),
  load_balancing = FALSE
)
}
\arguments{
\item{dt}{\link{data.table} object containing the cytometry data.
Rows represent cells, columns represent markers.
If this is not a \link{data.table} object, the function will warn you about it,
and then try to convert it to a \link{data.table} object.}

\item{markers}{character vector specifying the markers to run SuperCell on.}

\item{sample_colname}{character specifying the column in \code{dt} that denotes
the sample of a cell.}

\item{cell_id_colname}{character specifying the column in \code{dt} that denotes
the unique ID of a cell.}

\item{gam}{numeric specifying the gamma value to be used by SuperCell.
Default to 20.}

\item{k_knn}{numeric specifying the k value to be used by SuperCell's knn.
Default to 5.}

\item{BPPARAM}{A \linkS4class{BiocParallelParam} specifying how the samples
should be "supercelled" in parallel.
Default to SerialParam, meaning the samples will be processed in serial.
Please go the section on parallel processing for more details
on how to best supercell multiple samples in parallel.}

\item{load_balancing}{logical whether load balancing should be performed when
multiple samples are to "supercelled" in parallel.
Please go the section on parallel processing for more details
on how to best supercell multiple samples in parallel.
Default to FALSE.}
}
\value{
\code{runSuperCellCyto} will return a list with the following components:
\describe{
\item{\code{supercell_object}:}{A list containing the object returned by
SCimplify function. One object per sample.}
\item{\code{supercell_expression_matrix}:}{A \link{data.table} containing
the marker expression of all the supercells.
These are computed by taking the average marker expression of the cells
captured by each supercell.}
\item{\code{supercell_cell_map}:}{A \link{data.table} showing which cell is
captured by which supercell. This is very useful if you intend to work out
which supercell captures which cell.}
}
}
\description{
Run SuperCell on cytometry data stored as a \link{data.table} object.
This is a wrapper function around the \code{SCImplify} function in the
SuperCell R package by Bilous et.al, 2022.
We have enhanced it by adding the capacity to "supercell" multiple samples
in parallel through the use of \link{BiocParallel}, and by adding support to
"supercell" cytometry data.
More explanations are given in various sections below, and are further
expanded in our vignette.
}
\section{Supercell multiple samples in parallel}{

For the function to supercell multiple samples in parallel, you will need to supply
a \linkS4class{BiocParallelParam} (as BPPARAM parameter) that leverages parallel evaluation,
e.g., \linkS4class{MulticoreParam} or \linkS4class{SnowParam}.
Importantly, it is also recommended to set their number of tasks (task parameter) as
the number of samples you have, and to set the \code{load_balancing} parameter to TRUE.
That way, the jobs that are handling the large samples are responsible (mostly)
for only that sample, and that the small ones are handled by other jobs which are
handling much smaller samples.
}

\section{What is \code{cell_id_colname}}{

This is a column in \code{dt} containing a unique identifier for each cell.
Commonly, you will have to manually create this column as a FCS file does not
typically has a field which uniquely identify each cell.
You can create this ID by giving the cells a numeric value of 1 to however many
you have, and store this as a column in \code{dt}.
If you don't know how to do this, refer to our vignette.
}

\section{Computing PCA}{

By default, the function will start by computing PCA from all the markers
specified in \code{markers} parameter, and that 10 PCs are computed.
If there are less than 10 markers in the \code{markers} parameter, then the
number of PCs are set to however many markers there are in the \code{markers} parameter.

Notably, \emph{no} scaling or transformation were done on the markers' expressions
prior to computing the PCs.

\code{irlba} is not used to calculate PCA as cytometry data tend to only have a
handful of features (markers) compared to scRNAseq data.
Hence there is very little gain.
}

\section{Setting the supercell graining level}{

How many supercells will I get for my dataset? or to phrase it in another way,
can I estimate how many cells will be captured within each supercell?
That depends on what you set the \code{gam} parameter to.

The \code{gam} parameter is represented by the formula \code{gamma=n_cells/n_supercells}
where \code{n_cells} denotes the number of cells and \code{n_supercells} denotes the
number of supercells to be created.
By resolving this formula, we can roughly estimate how many supercells you will
get at the end, and thus, \emph{approximately} how many cells will be captured
within each supercell.

Generally, the smaller the \code{gam} parameter is, the more supercells
you will get.
Say for instance you have 10,000 cells.
If \code{gam} is set to 10, you will end up with about 1,000 supercells, whereas
if \code{gam} is set to 50, you will end up with about 200 supercells.

Conversely, as you get more supercells (i.e. smaller \code{gam} value),
the smaller their size will be.
In other words, each of them will be capturing less cells.
Importantly, one cannot expect all the supercells to be of the same size.
Some will capture more/less cells than the other, and that is it not trivial
to estimate how many will be captured beforehand.
We may look into swapping the \code{gam} value to how many cells to be captured
within each supercell \emph{in the future}.
More thoughts are required into whether this make sense.

Lastly, for now, a \code{gam} value for all your samples
(read the section above if you are not sure what I mean by samples here).
\emph{In the future}, we can perhaps look into setting different \code{gam} values
for different samples.
}

\section{Computing kNN network}{

The parameter \code{k_knn} governs and the k value used to compute the
single-cell kNN network.
Actual (not approximate) kNN network is created, and walktrap algorithm is
used to form supercells from the kNN network.
}

\examples{
# Simulate some data
set.seed(42)
cyto_dat <- simCytoData(nmarkers = 10, ncells = rep(2000,2))

# Setup the columns designating the markers, samples, and cell IDs
marker_col <- paste0("Marker_", seq_len(10))
sample_col <- "Sample"
cell_id_col <- "Cell_Id"

supercell_dat <- runSuperCellCyto(
    cyto_dat, marker_col,
    sample_col, cell_id_col
)

}
\author{
Givanna Putri
}
